C++设计模式
=======================================================================================



面向对象设计原则
----------------------------------------------------------------------------------------

1. 依赖倒置原则(DIP)

    > * 高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。
    > * 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。

2. 开放封闭原则(OCP)

    > * 对扩展开放，对更改封闭。
    > * 类模块应该是可扩展的，但是不可修改。

3. 单一职责原则(SRP)

    > * 一个类应该仅有一个引起它变化的原因。
    > * 变化的方向隐含着隐含着类的责任。

4. Liskov替换原则(LSP)

    > * 子类必须能够替换他们的基类(IS-A)。
    > * 继承表达抽象。

5. 接口隔离原则(ISP)
    
    > * 不应该强迫客户程序依赖它们不用的方法。
    > * 接口应该小而完备。

6. 优先使用对象组合，而不是类继承

    > * 类继承通常为 “白箱复用”，对象组合通常为“黑箱复用”。
    > * 继承在某种程度上破坏了封装性，子类父类耦合度高。
    > * 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

7. 封装变化点

    > * 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

8. 针对接口编程，而不是针对实现编程

    > * 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
    > * 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
    > * 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。


模板方法模式(Template Method Pattern)
----------------------------------------------------------------------------------------------

* 定义：定义一个操作中的算法骨架（稳定），而将一些步骤延迟变化到子类中.Template Method使得子类可以不改变（复用）一个算法的结构即可重定义(overwrite 重写)该算法的某些特定步骤。

* 要点总结
    > Tempate Method 是一种非常基础性的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制(虚函数的多态性)为很多应用程序框架提供了灵活的扩展点,是代码复用的基本实现结构。

    > 除了可以灵活应对子步骤的变化外，"不要调用我,让我来调用你“ 的反向控制结构是Template Method 的典型应用。

    > 在具体实现方面,被Template Method调用的虚方法可以具有实现，也可以没有任何实现(抽象方法，纯虚方法),但一般推荐将他们设置为protected方法。

策略模式(Strategy Pattern)
-------------------------------------------------------------------------------------------------

* 定义: 定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展，子类化）。

* 要点总结
    > Strategy 及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。

    > Strategy 提供了用条件判断判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要Strategy模式。

    > 如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个Strategy对象，从而节省对象开销。

观察者模式(Observer Pattern)
-------------------------------------------------------------------------------------------------

* 定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

* 要点总结
    > 使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的关系达到松耦合。

    > 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。

    > 观察者自己决定是否需要订阅通知，目标对象对此一无所知。

    > Observer 模式是基于事件的UI框架中非常常用的设计模式，也是MVC模式的一个重要组成部分。

装饰模式(Decorator Pattern)
------------------------------------------------------------------------------------------------

* 定义：动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码，减少子类个数）。

* 要点总结
    > 通过采用组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了使用继承带来的“灵活性差”和“多子类衍生问题”。

    > Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。

    > Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为装饰的功能。

桥模式(Bridge Pattern)
----------------------------------------------------------------------------------------------

* 定义：将抽象部分（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。

* 要点总结
    > Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，即“子类化”它们。

    > Bridge 模式有时候类似于多继承方案，但是多继承方案往往违背单一职责原则（即一个类只有一个变化的原则），复用性比较差。Bridge模式是比多继承方案更好的解决方法。

    > Bridge模式的应用一般在“两个非常强的变化维度”，有时一个类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。

工厂方法模式(Factory Method Pattern)
------------------------------------------------------------------------------------------------

* 定义：定义一个创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟（目的：解耦，手段：虚函数）到子类。

* 要点总结
    > Factory Method 模式用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系会导致软件的脆弱。

    > Factory Method 模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好的解决了这种紧耦合关系。

    > Factory Method 模式解决“单个对象”的需求变化。缺点在于要求创建方法/参数相同。

抽象工厂模式(Abstract Factory Pattern)
-------------------------------------------------------------------------------------------------

* 定义：提供一个接口，让该接口负责创建一系列“相关或相互依赖的对象”，无需指定它们具体的类。

* 要点总结

    > 如果没有应对“多系列对象构建”的需求变化，则没有必要使用Abstract Factory 模式，这时候使用简单的工厂完全可以。

    > “系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。

    > Abstract Factory 模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。

原型模式(Prototype Pattern)
----------------------------------------------------------------------------------------------------

* 定义： 使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。

* 要点总结
    > Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”。

    > Prototype 模式对于“如何创建易变类的实体对象”采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方Clone。

    > Prototype 模式中的clone方法可以利用某些框架中的序列化来实现深拷贝。

构建器模式(Builder Pattern)
-------------------------------------------------------------------------------------------------

* 定义：将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。

* 要点总结
    > Builder模式主要用于“分步骤构建一个复杂的对象”。在这其中“分步骤是一个稳定的算法”，而复杂对象的各个部分则经常变化。

    > 变化点在哪里，封装哪里——Builder模式主要在于应对“复杂对象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建算法”的需求变动。

    > 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别（C++ vs. C#）

单例模式（Singleton Pattern）
--------------------------------------------------------------------------------------------------

* 定义：保证一个类仅有一个实例，并提供一个该实例的全局访问点。

* 要点总结
    > Singleton模式中的实例构造器可以设置为ptotected以允许子类派生。

    > Singleton模式一般不要支持拷贝构造函数和Clone接口，因为这有可能导致多个对象实例，与Singleton模式的初衷违背。

    > 如何实现多线程环境下安全的Singleton?注意对双检查锁的正确实现。 

享元模式（Flyweight Pattern）
--------------------------------------------------------------------------------------------------

* 定义：运用共享技术有效地支持大量细粒度的对象。

* 要点总结
    > 面向对象很好地解决了抽象性的问题，但是作为一个运行在机器上的程序实体，我们需要考虑对象的代价问题。Flyweight主要解决面向对象的代价问题，一般不触及面向对象的抽象性问题。

    > Flyweight采用对象共享的做法来降低系统中对象的个数，从而降低细粒度对象给系统带来的内存压力。在具体实现方面，要注意对象状态的处理。

    > 对象的数量太大从而导致对象内存开销加大——什么样的数量才算大？这需要我们仔细的根据具体应用情况进行评估，而不能凭空臆断。

门面模式（Facade Pattern）
--------------------------------------------------------------------------------------------------

* 定义：为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。

* 要点总结
    > 从客户程序的角度来看，Facade模式简化了整个组件系统的接口，对于组件内部与外部客户程序来说，达到了一种解耦的效果——内部子系统的任何变化不会影响到Facade接口的变化。

    > Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。

    > Facade模式并非一个集装箱，可以任意地放进多个对象。Facade模式中组件的内部应该是“相互耦合关系比较大的一系列组件”，而不是一个简单的功能集合。

代理模式（Proxy Pattern）
-----------------------------------------------------------------------------------------------------------

* 定义：为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。

* 要点总结
    > “增加一层间接层”是软件系统中对许多复杂问题的一种常见解决方法。在面向对象系统中，直接使用某些对象会带来很多问题，作为间接层的proxy对象便是解决这一问题的常用手段。

    > 具体proxy设计模式的实现方法、实现粒度都相差很大，有些可能对单个对象做细粒度的控制，如copy-on-write技术，有些可能对组件模块提供抽象代理层，在架构层次对对象做proxy。

    > Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的。

适配器模式（Adapter Pattern）
----------------------------------------------------------------------------------------------------------

* 定义：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

* 要点总结
    > Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。

    > GoF 23 定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现方式，一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。

    > Adapter模式可以实现的非常灵活，不必拘泥于Gof23 中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。
